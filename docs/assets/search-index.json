[{"title":"Introduction","url":"/","sections":[{"title":"Introduction","content":"Kequapp is a non-intrusive Node.js web application framework designed to leverage Node's built-in features while staying out of your way. It can be used to create performant api's, html pages, and anything you can think of. Kequapp provides a robust and flexible foundation to build your web applications with ease."},{"title":"Why Kequapp?","content":"Kequapp is crafted with simplicity and modularity in mind. Here are some key features that make Kequapp stand out: Modular Framework**: Build your application with a modular structure, making it easy to manage and scale. CORS Support**: Handle Cross-Origin Resource Sharing effortlessly with built-in support. Body Parsing**: Comprehensive body parsing capabilities, including support for multipart requests. Async/Await Everywhere**: Modern asynchronous handling with async/await throughout the framework. Static File Serving**: Serve static files efficiently and effortlessly. Unit Testing Tool**: Built-in unit testing tool to ensure your application is robust and reliable. No Dependencies**: Kequapp has zero dependencies, ensuring a lightweight and fast setup. Node Features and Functionality**: Exposes and leverages the full power of Node.js."},{"title":"Getting Started","content":"I want to make your experience with Kequapp as smooth as possible. Hereâ€™s a quick guide to get you started: Installation: Install Kequapp via npm with a simple command: npm i kequapp Hello World: Follow the simple Hello World example to see it in action. I believe Kequapp will provide you with the tools and flexibility you need to build great web applications. Dive into the documentation to explore more about each feature and how to leverage them in your projects. If you have any questions, need further assistance, or want to contribute, feel free to reach out on the GitHub page."}]},{"title":"Basic Concepts","url":"/docs/basic-concepts.html","sections":[{"title":"Basic Concepts","content":"Understanding the core concepts of Kequapp will help you build applications efficiently and effectively. Here are the fundamental components that make up the Kequapp framework:"},{"title":"Content Type","content":"The 'Content-Type' header has a huge impact on the way your application responds. Based on this header Kequapp determines which error handler to use, and which renderer to use. This structure helps to ensure that the correct 'Content-Type' is being returned whenever possible. A user expecting to see a 'application/json' response instead of a 'text/html' response will probably get one. Be sure to set your 'Content-Type' header deliberately and make use of error handlers and renderers that are set up to take advantage of this."},{"title":"Branches","content":"The createApp function acts as the trunk of the tree where all behaviors derive. It is effectively a branch that stems from '/' and is a great place to add functionality that will effect the whole application. The app can have branches added using createBranch that also resolve to '/', branches are not overridden. In the background all route endpoints are sorted and cataloged upon app startup. Therefore branching your application with different functionality and same urls is fine. Even if you have many branches with similar urls containing many routes with different bahavior, Kequapp will sort this out behind the scenes. Duplicate routes however will give you a warning. The final result of your app should contain routes that are unique either by url or method (GET, POST, etc.) so that there is no conflict."},{"title":"Actions","content":"The createAction function is simply a wrapper for a function, for cases where you find yourself writing functionality outside the scope of a branch. This is to provide types, but ultimately a function is an action. Actions are littered throughout your application's code base and define the vast majority of your application's behavior. These can be asyncronous and always run in sequence. They are used to check authorization, change response headers, render a response, and more. Most of your code will be wrapped in many different actions. It serves to break up your code and make it reusable. Each action comes with many bundle properties that make it easy to manage a web application."},{"title":"CORS","content":"Kequapp is the only JavaScript web framework I am aware of that correctly responds to OPTIONS requests. What's more, it still gives you additional control to suit your needs. This is an example of where the structure of this framework shines. Every request your application receives knows what matching routes exist at that url. This is what OPTIONS responses are supposed to communicate to the client. If you need CORS in your application you'll be able to handle those requests as intended."},{"title":"Body","content":"Many route endpoints do not even care about the body of a request. The getBody function is a helper tool that will retrieve that data. It is used inline and awaited in Kequapp, giving you a lot of control over what it is doing. If your application makes use of the body of requests in a unique way this framework has you covered. From field validation, processing and formatting incoming data, to allowing you to do it all yourself. Take advantage of the speed gained from not needing to parse the body of a request up front."},{"title":"You're all set","content":"Understanding these core concepts will help you build robust and scalable applications with Kequapp. As you explore the documentation, you'll find more details and examples to guide you through each feature. Thank you for trying Kequapp I hope it's as enjoyable for you as it is for myself!"}]},{"title":"Installation","url":"/getting-started/installation.html","sections":[{"title":"Installation","content":"To install Kequapp, run the following command: npm i kequapp It is good practice to make both a server.js file and app.js file, to keep concerns separated. Use server.js as your entry point to the application and access app.js for testing purposes."},{"title":"package.json","content":"{ \"scripts\": { \"start\": \"node ./server.js\" } } If you like, nodemon can be used instead to restart the server automatically whenever code changes are made."}]},{"title":"Hello World","url":"/getting-started/hello-world.html","sections":[{"title":"Hello World","content":""},{"title":"server.js","content":"import { createServer } from 'http'; import app from './app'; createServer(app).listen(4000, () => { console.log('Server running at http://localhost:4000'); });"},{"title":"app.js","content":"import { createApp } from 'kequapp'; export default createApp({ routes: [ { method: 'GET', url: '/', actions: [() => 'Hello world!'] } ] });"},{"title":"Outcome","content":"This example responds to all GET and HEAD requests made to '/' at the base of your application, otherwise a 404 Not Found error will be thrown. Kequapp comes with a built-in error handler and some renderers, so for now this is all you need."}]},{"title":"createApp","url":"/core-api/create-app.html","sections":[{"title":"createApp","content":"import { createApp } from 'kequapp'; The createApp function is the entry point of your application. It prepares your app to handle incoming requests and serves as the main event handler for Node's createServer method. It is otherwise identical to the createBranch function."},{"title":"Example","content":"const app = createApp({ routes: [ { method: 'GET', url: '/', actions: [() => 'Hello world!'] } ] });"}]},{"title":"createBranch","url":"/core-api/create-branch.html","sections":[{"title":"createBranch","content":"import { createBranch } from 'kequapp'; | key | description | default | | ---- | ---- | ---- | | url | Pathname | '/' | | actions | Sequence | [] | | logger | Logger | console | | autoHead | HEAD request | true | | routes | Routes | [] | | branches | Branches | [] | | errorHandlers | Error handlers | [] | | renderers | Renderers | [] | The createBranch function allows you to organize your routes into logical sections, or branches. Each branch can have its own set of routes, actions, error handlers, and renderers. A branch of the application will distribute the given options, actions, error handlers, and renderers through a section of branches and routes."},{"title":"Example","content":"createBranch({ branches: [ { url: '/api/users', actions: [setJson], routes: [ { method: 'GET', url: '/', actions: [() => ({ result: [] })] }, { method: 'GET', url: '/:id', actions: [({ params }) => ({ userId: params.id })] } ] } ], routes: [ { method: 'GET', url: '/admin/dashboard', actions: [loggedIn, ({ context }) => Hello admin ${context.auth}] } ] });"}]},{"title":"createRoute","url":"/core-api/create-route.html","sections":[{"title":"createRoute","content":"import { createRoute } from 'kequapp'; | key | description | default | | ---- | ---- | ---- | | method \\* | Method | | | url \\* | Pathname | | | actions | Sequence | [] | | logger | Logger | console | | autoHead | HEAD request | true | Routes define the endpoints of your application. The createRoute function must specify a method (GET, POST, etc.) and a url. The url is a pathname that the route should respond to and must always start with '/'. The actions parameter is a list of functions that are executed in order when the endpoint is accessed."},{"title":"Example","content":"createRoute({ method: 'POST', url: '/admin/users', actions: [loggedIn, () => 'User created!'] }); This example has two actions. One called loggedIn, then a second that returns a value which is therefore delivered to a renderer."}]},{"title":"createAction","url":"/core-api/create-action.html","sections":[{"title":"createAction","content":"import { createAction } from 'kequapp'; Actions are functions that process requests. They can modify the request and response objects, perform authentication, validation, or any other processing needed. Actions can be asyncronous and are executed in sequence. These are fundamental to the structure of your application and you should create as many of them as you need. Any action that throws an error will invoke an error handler and one that returns a value will invoke a renderer. The createAction function acts as a wrapper for a function the purpose of which is to provide it types."},{"title":"Example","content":"const setJson = createAction(({ res }) => { res.setHeader('Content-Type', 'application/json'); }); const loggedIn = createAction(({ req, context }) => { if (req.headers.authorization !== 'mike') { throw Ex.Unauthorized(); } context.auth = req.headers.authorization; }); In these examples the setJson action sets the 'Content-Type' header to 'application/json', and the loggedIn action checks for an 'authorization' header."}]},{"title":"createErrorHandler","url":"/core-api/create-error-handler.html","sections":[{"title":"createErrorHandler","content":"import { createErrorHandler } from 'kequapp'; | key | description | default | | ---- | ---- | ---- | | contentType \\* | Content type | | | action \\* | Action | | Error handlers are invoked when an action throws an exception. They turn errors into useful information that is sent to a renderer in place of the expected response. The createErrorHandler function must specify a contentType ('application/json', 'text/html', etc.) and an action to manipulate the information into a response. The first parameter of an error handler is the error ex that has been thrown, after that it is the same as any action. It can return a value to invoke a renderer, finalize the response, change headers, or anything that you need."},{"title":"Example","content":"createErrorHandler({ contentType: 'text/*', action: (ex, { url }) => { return ${url.pathname} ${ex.statusCode}: ${ex.message}; } }); Errors thrown within an error handler or the renderer it invokes will cause a fatal exception and an empty body will be delivered to the client. For a good example of how to write an error handler see this repo's /src/built-in directory. Kequapp will turn any error into json by default, and return a json formatted response. However this behavior can be overriden by writing your own error handlers that support more specific content types."}]},{"title":"createRenderer","url":"/core-api/create-renderer.html","sections":[{"title":"createRenderer","content":"import { createRenderer } from 'kequapp'; | key | description | default | | ---- | ---- | ---- | | contentType \\* | Content type | | | action \\* | Action | | Renderers are responsible for finalizing the response to the client. When an action returns a value, a renderer is invoked to send the response. You can create custom renderers for different content types. The createRenderer function must specify a contentType ('application/json', 'text/html', etc.) and an action to manipulate the information into a response. The first parameter of an renderer is the value payload that was returned. Here is a simple example of an HTML renderer: createRenderer({ contentType: 'text/html', action: (payload, { req, res }) => { const html = myMarkupRenderer(payload); res.setHeader('Content-Length', Buffer.byteLength(html)); // finalize response if (req.method === 'HEAD') { res.end(); } else { res.end(html); } } }); For good examples of how to write a renderer see this repo's /src/built-in directory. Kequapp comes with a renderer for 'application/json' and 'text/*', however these can be overriden by writting your own renderers with those content types."}]},{"title":"Responding to Requests","url":"/advanced-usage/responding-to-requests.html","sections":[{"title":"Responding to Requests","content":"Any action may terminate a request one of three ways: Throw an error - An error handler is invoked. Return a value - A renderer is invoked. Finalize the response Finalizing a response is for cases where you need the most control. It allows you to terminate the response any way you need without invoking a renderer. const loggedIn = createAction(({ req, res }) => { // must be authenticated! if (!req.headers.authorization) { // cause redirect res.statusCode = 302; res.setHeader('Location', '/login'); // finalize response to ignore remaining actions res.end(); } }); const setJson = createAction(({ res }) => { res.setHeader('Content-Type', 'application/json'); }); createRoute({ method: 'GET', url: '/api/users', actions: [loggedIn, setJson, () => { // return a value to invoke a renderer return { users: [{ name: 'April' }, { name: 'Leo' }] }; }] }); In this example if the client did not provide an 'authorization' header, the loggedIn action will finalize the response. This terminates the request and skips all remaining actions. Otherwise the setJson action sets the 'Content-Type' of the response to 'application/json'. The last remaining action returns a value. This invokes a renderer best matching the 'Content-Type' header, in this example a renderer matching 'application/json' will be used. The appropriate renderer will finalize a response to the client. If an error was thrown then an error handler best matching the 'Content-Type' header would intercept the response."}]},{"title":"CORS and OPTIONS Requests","url":"/advanced-usage/cors-and-options-requests.html","sections":[{"title":"CORS and OPTIONS Requests","content":"CORS behavior is managed by headers as shaped by actions. The framework will automatically add default headers you can use for basic support. To enable CORS, your application needs to respond to preflight requests, therefore you define an OPTIONS route. By default, any url that has a matching OPTIONS route is decorated with 'Access-Control-Allow-Origin' with a value of '*'. This alone is enough to handle the majority of CORS-related cases and functionality. createApp({ routes: [ { method: 'OPTIONS', url: '/**' } ] }); The framework automatically attaches four additional headers to OPTIONS responses. 'Valid' and 'Access-Control-Allow-Methods' will correctly identify all methods available at the requested url. 'Access-Control-Allow-Headers' will return headers that the client specified. 'Content-Length' will be 0. In addition, the default response code for OPTIONS requests is 204. To change any of this behavior or add more headers to OPTIONS responses, you use an action. createApp({ routes: [ { method: 'OPTIONS', url: '/**', actions: [({ res }) => { res.setHeader('Access-Control-Max-Age', 86400); res.setHeader('Vary', 'Access-Control-Request-Headers'); }] } ] }); As OPTIONS responses do not need to include a body, you can safely leave the route like this without rendering. The simplest place to override 'Access-Control-Allow-Origin' is at the base of the application but you may adjust this as needed. The createApp method accepts actions and is a convenient place to set global headers. const strictCors = createAction(({ res, methods }) => { if (methods.includes('OPTIONS')) { res.setHeader('Access-Control-Allow-Origin', 'https://foo.com'); } }); createApp({ actions: [strictCors] }); This would cause all responses to include 'Access-Control-Allow-Origin' but only if there is an OPTIONS route; one should be included for the mechanism to work correctly. Please see the MDN documentation on CORS for more information about headers that the client expects to see."}]},{"title":"HEAD Requests","url":"/advanced-usage/head-requests.html","sections":[{"title":"HEAD Requests","content":"By default, if a HEAD request has no matching route, your application will use a matching GET route in its place. Therefore it is important to keep in mind that HEAD requests follow the same flow as GET requests in your application. This behavior can be disabled by setting the parameter autoHead to false in any branch or route. Occasionally, you may need to differentiate between the two as it is generally understood that a HEAD request does not modify data. In this case, looking at the value of req.method can be useful. createRoute({ method: 'GET', url: '/api/users', actions: [({ req }) => { if (req.method === 'HEAD') { // head request } }] }); In most cases, HEAD and GET requests should run the same code, so you have nothing to worry about. Detection of HEAD requests is already handled by the renderers that are built-in to the framework. Largely what will happen is no body will be sent to the client, which is what a HEAD request wanted."}]},{"title":"Ex","url":"/utilities/ex.html","sections":[{"title":"Ex","content":"import { Ex } from 'kequapp'; An unhandled exception from your application results in a 500 Internal Server Error. If you would like an error with a different status code, there is a helper tool for that. createAction(() => { throw Ex.NotFound(); }); The following examples are roughly equivalent: createAction(() => { throw Ex.NotFound('Custom message', { extra: 'info' }); }); createAction(() => { throw Ex.StatusCode(404); }); createAction(() => { throw Ex.StatusCode(404, 'Custom message', { extra: 'info' }); }); This makes it easy to utilize any status code 400 and above. These methods create errors with correct stack traces that can be thrown directly without the use of new. Any extra information added to the end of the parameter list will be available by accessing ex.info. With the default error handler this information is stripped off along with the stack trace in production mode. | Name | Status Code | Message | | ---- | ---- | ---- | | BadRequest | 400 | 'Bad Request' | | Unauthorized | 401 | 'Unauthorized' | | PaymentRequired | 402 | 'Payment Required' | | Forbidden | 403 | 'Forbidden' | | NotFound | 404 | 'Not Found' | | MethodNotAllowed | 405 | 'Method Not Allowed' | | NotAcceptable | 406 | 'Not Acceptable' | | ProxyAuthenticationRequired | 407 | 'Proxy Authentication Required' | | RequestTimeout | 408 | 'Request Timeout' | | Conflict | 409 | 'Conflict' | | Gone | 410 | 'Gone' | | LengthRequired | 411 | 'Length Required' | | PreconditionFailed | 412 | 'Precondition Failed' | | PayloadTooLarge | 413 | 'Payload Too Large' | | URITooLong | 414 | 'URI Too Long' | | UnsupportedMediaType | 415 | 'Unsupported Media Type' | | RangeNotSatisfiable | 416 | 'Range Not Satisfiable' | | ExpectationFailed | 417 | 'Expectation Failed' | | ImATeapot | 418 | 'I'm a teapot' | | MisdirectedRequest | 421 | 'Misdirected Request' | | UnprocessableEntity | 422 | 'Unprocessable Entity' | | Locked | 423 | 'Locked' | | FailedDependency | 424 | 'Failed Dependency' | | TooEarly | 425 | 'Too Early' | | UpgradeRequired | 426 | 'Upgrade Required' | | PreconditionRequired | 428 | 'Precondition Required' | | TooManyRequests | 429 | 'Too Many Requests' | | RequestHeaderFieldsTooLarge | 431 | 'Request Header Fields Too Large' | | UnavailableForLegalReasons | 451 | 'Unavailable For Legal Reasons' | | InternalServerError | 500 | 'Internal Server Error' | | NotImplemented | 501 | 'Not Implemented' | | BadGateway | 502 | 'Bad Gateway' | | ServiceUnavailable | 503 | 'Service Unavailable' | | GatewayTimeout | 504 | 'Gateway Timeout' | | HTTPVersionNotSupported | 505 | 'HTTP Version Not Supported' | | VariantAlsoNegotiates | 506 | 'Variant Also Negotiates' | | InsufficientStorage | 507 | 'Insufficient Storage' | | LoopDetected | 508 | 'Loop Detected' | | BandwidthLimitExceeded | 509 | 'Bandwidth Limit Exceeded' | | NotExtended | 510 | 'Not Extended' | | NetworkAuthenticationRequired | 511 | 'Network Authentication Required' |"}]},{"title":"staticDirectory","url":"/utilities/static-directory.html","sections":[{"title":"staticDirectory","content":"import { staticDirectory } from 'kequapp'; | key | description | default | | ---- | ---- | ---- | | location \\* | Directory | | | contentTypes | Content types | {} | | indexes | File names | [] | The staticDirectory function creates an action intended to pair a 'wild' parameter with a static directory relative to the root of your project. Therefore the url should end with '/**'. An array of indexes, for example ['index.html'] may be provided to resolve when the request points at a directory. A 'Content-Type' header is guessed based on every asset's file extension. If there are assets in the directory with unusual file extensions, then additional contentTypes may be provided. const staticAssets = staticDirectory({ location: '/my-assets-dir', contentTypes: { '.3gp': 'audio/3gpp', }, indexes: ['index.html'], }); createRoute({ method: 'GET', url: '/assets/**', actions: [staticAssets], }); Additional control can be obtained by using an action. const prepare = createAction(({ res, params }) => { res.setHeader('Cache-Control', 'max-age=604800'); if (params.wild === '/secret.txt') { throw Ex.NotFound(); } }); createRoute({ method: 'GET', url: '/assets/**', actions: [prepare, staticAssets], });"}]},{"title":"sendFile","url":"/utilities/send-file.html","sections":[{"title":"sendFile","content":"import { sendFile } from 'kequapp'; The sendFile function delivers a file to the client and finalizes the response. This is asynchronous and must be awaited. Otherwise the application might get confused as it continued processing the request unexpectedly. createRoute({ method: 'GET', url: '/db.json', actions: [async ({ req, res }) => { await sendFile(req, res, '/db/my-db.json'); }], }); A fourth parameter may be provided defining a 'Content-Type' this header is otherwise guessed from the file extension."}]},{"title":"inject","url":"/utilities/inject.html","sections":[{"title":"inject","content":"import { inject } from 'kequapp'; You may unit test your application without starting a server by using the inject tool. The first parameter is your app, then options used to populate the request. The returned req value is a simulation of Node's built-in ClientRequest object and is a Transform stream. The returned res value is a simulation of Node's built-in ServerResponse object and is also a Transform stream. The returned getResponse tool waits for your application to finish processing, and parses the response. It is very similar to getBody as described earlier. You could inspect what your application is doing using the req and res objects in real-time instead if that's what you need. it('reads the authorization header', async () => { const { getResponse, res } = inject(app, { url: '/admin/dashboard', headers: { Authorization: 'mike', }, }); const body = await getResponse(); assert.strictEqual(res.getHeader('Content-Type'), 'text/plain'); assert.strictEqual(body, 'Hello admin mike!'); }); All requests are automatically finalized when using inject unless the body parameter is set to null. Doing this will allow you to write to the stream in cases where more precise testing is necessary. The following two examples are the same. const { getResponse } = inject(app, { method: 'POST', url: '/users', headers: { 'Content-Type': 'application/json' }, body: '{ \"name\": \"April\" }', }); const body = await getResponse(); const { getResponse, req } = inject(app, { method: 'POST', url: '/users', headers: { 'Content-Type': 'application/json', }, body: null, }); // finalize request req.end('{ \"name\": \"April\" }'); const body = await getResponse(); Note that getResponse will not resolve until the request is finalized."}]},{"title":"Bundle Properties","url":"/additional-information/bundle-properties.html","sections":[{"title":"Bundle Properties","content":"Properties such as req, res, and context are found throughout the examples. These properties are generated for every request and available in every action."},{"title":"req","content":"Node's ClientRequest object. It is not modified by this framework so we can rely on the official documentation to use it. This represents the client request."},{"title":"res","content":"Node's ServerResponse object. It is not modified by this framework so we can rely on the official documentation to use it. This represents the server response."},{"title":"url","content":"If you need to know more about what the client is looking at in the address bar you can do so here. It is a URL instance generated from the req object. Useful for examining the query string, for example by digging into searchParams. createRoute({ method: 'GET', url: '/hotels', actions: [({ url }) => { const page = url.searchParams.get('page'); const categories = url.searchParams.getAll('categories'); // page ~= '2' // categories ~= ['ac', 'hottub'] }] });"},{"title":"methods","content":"An array of methods available in your app at the current url (GET, POST, OPTIONS, etc.)."},{"title":"context","content":"A place to store variables derived by actions, you might use these variables elsewhere in your code. Changes can be made here whenever you want and it may be populated with anything. Maybe authentication details, a user object, or any data that's useful in other places."},{"title":"params","content":"When defining a route you may specify parameters to extract by prefixing a colon ':' character in the url. If you specified a route such as '/users/:userId' it will have a params item called 'userId'. Use a double asterisk '/**' to accept anything for the remainder of the url, it will have a params item called 'wild'. Param values are always a string."},{"title":"cookies","content":"Includes helpers for get, set, and remove. The set method takes an optional third parameter with expires, maxAge, domain, path, secure, httpOnly, partitioned, and sameSite. createAction(({ cookies }) => { // get a cookie const value: string | undefined = cookies.get('MyCookie'); // set a cookie cookies.set('MyCookie', 'NewValue', { maxAge: 10000 }); // remove a cookie cookies.remove('MyCookie'); });"},{"title":"logger","content":"The logger being used by the application."},{"title":"getBody","content":"This method can be used in many ways so we will look at it in detail the next section."}]},{"title":"getBody","url":"/additional-information/get-body.html","sections":[{"title":"getBody","content":"Node delivers the body of a request in chunks. It is not necessary to wait for the request to finish before processing it. In most cases, you just want the data and therefore a helper method getBody is provided which you may use to await body from the completed request. createRoute({ method: 'POST', url: '/users', actions: [async ({ getBody }) => { const body = await getBody(); // body ~= { //     name: 'April' // } return User creation ${body.name}!; }] }); It takes an options object which can be used to parse and normalize a client request into useful data in a large assortment of different ways."},{"title":"multipart","content":"Causes the method to return both body and files. If the client didn't send any files, or it wasn't a multipart request the second parameter will be an empty array. createRoute({ method: 'POST', url: '/users', actions: [async ({ getBody }) => { const [body, files] = await getBody({ multipart: true }); // body ~= { //     name: 'April' // } // files ~= [{ //     headers: { //         'content-disposition': 'form-data; name=\"avatar\" filename=\"my-cat.png\"', //         'content-type': 'image/png;' //     }, //     contentType: 'image/png', //     name: 'avatar', //     filename: 'my-cat.png', //     data: Buffer // }] return User creation ${body.name}!; }] });"},{"title":"raw","content":"Causes the body to be processed as minimally as possible and return a single buffer. This is especially useful when your application expects a content type other than 'application/x-www-form-urlencoded', 'application/json', or 'multipart/form-data'. createRoute({ method: 'POST', url: '/users', actions: [async ({ getBody }) => { const data = await getBody({ raw: true }); // data ~= Buffer return 'Image received!'; }] }); When combined with multipart, the body is parsed into an array of separate buffers with their respective headers. createRoute({ method: 'POST', url: '/users', actions: [async ({ getBody }) => { const parts = await getBody({ raw: true, multipart: true }); // parts ~= [{ //     headers: { //         'content-disposition': 'form-data; name=\"name\"' //     }, //     data: Buffer // }, { //     headers: { //         'content-disposition': 'form-data; name=\"avatar\" filename=\"my-cat.png\"', //         'content-type': 'image/png;' //     }, //     data: Buffer // }] return User creation ${parts[0].data.toString()}!; }] });"},{"title":"skipNormalize","content":"By default, the data received is pushed through some body normalization. This is so that the body you receive is in a format you'd expect and is therefore easier to work with. Normalization is directed by arrays, required, numbers, booleans, and validate. Disable body normalization with either raw or skipNormalize."},{"title":"arrays","content":"The provided list of fields are converted into arrays. Fields that are not specified will return only the first value. This is because the framework only knows that a field is an array when it receives more than one value for a given name from the client. It would be inconvenient if parameters are sometimes arrays, and therefore instead are explicit. createRoute({ method: 'POST', url: '/users', actions: [async ({ getBody }) => { const body = await getBody({ arrays: ['ownedPets'] }); // body ~= { //     ownedPets: ['cat'], //     age: '23', //     name: 'April' // } }] });"},{"title":"required","content":"The provided list of fields are not null or undefined. It's a quick way to throw a 422 Unprocessable Entity error. These fields might still be empty, but at least something was sent and you know you can operate on them. When a required field is also an arrays field the array is sure to have at least one value."},{"title":"numbers","content":"The provided list of fields will throw a 422 Unprocessable Entity error if any value is provided which parses into NaN. Otherwise they are converted into numbers. When a numbers field is also an arrays field the array is all numbers."},{"title":"booleans","content":"The provided list of fields are converted into false if the value is falsy, '0', or 'false' (case insensitive), otherwise true. When a booleans field is also an arrays field the array is all booleans. When a booleans field is also a numbers field the value is first converted to a number and then to a boolean this is not recommended."},{"title":"validate","content":"After normalization, this method further ensures the validity of the data. Returning anything throws a 422 Unprocessable Entity error. interface TBody { ownedPets: string[]; age: number; name: string; } createRoute({ method: 'POST', url: '/users', actions: [async ({ getBody }) => { const body = await getBody({ arrays: ['ownedPets'], required: ['age', 'name'], numbers: ['age'], validate (result) { if (result.ownedPets.length > 99) { return 'Too many pets'; } if (result.name.length < 3) { return 'Name is too short'; } } }); // body ~= { //     ownedPets: ['Maggie', 'Ralph'], //     age: 23, //     name: 'April' // } }] }); You know it is safe to use result.ownedPets.length in this example because it is listed as an arrays field and therefore certain to be an array. result.name is also safe to use because it is listed as a required field and therefore certain to exist."}]},{"title":"Logger","url":"/additional-information/logger.html","sections":[{"title":"Logger","content":"One of the options provided to createBranch is a logger parameter. The default logger for the application is a simple object with methods for error, warn, info, http, verbose, debug, silly, and log which each map roughly to console. Overriding this logger requires an object with some or all of the same methods. The logger is available in all actions using the logger property. This is where you may elect to make some logging silent for example the http logger is used whenever a request is resolved."}]},{"title":"Conclusion","url":"/additional-information/conclusion.html","sections":[{"title":"Conclusion","content":"This should be able to handle the construction of complicated applications that do anything you could want. Please feel free to contribute or create issue tickets on the GitHub page."}]}]
