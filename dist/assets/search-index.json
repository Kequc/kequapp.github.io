[{"title":"Introduction","url":"/","sections":[{"title":"Why Kequapp?","content":"\nKequapp is crafted with simplicity and modularity in mind. Here are some key features that make Kequapp stand out:\n\n- **Modular Framework**: Build your application with a modular structure, making it easy to manage and scale.\n- **CORS Support**: Handle Cross-Origin Resource Sharing effortlessly with built-in support.\n- **Body Parsing**: Comprehensive body parsing capabilities, including support for multipart requests.\n- **Async/Await Everywhere**: Modern asynchronous handling with async/await throughout the framework.\n- **Static File Serving**: Serve static files efficiently and effortlessly.\n- **Unit Testing Tool**: Built-in unit testing tool to ensure your application is robust and reliable.\n- **No Dependencies**: Kequapp has zero dependencies, ensuring a lightweight and fast setup.\n- **Node Features and Functionality**: Exposes and leverages the full power of Node.js.\n\n"},{"title":"Getting Started","content":"\nWe want to make your experience with Kequapp as smooth as possible. Hereâ€™s a quick guide to get you started:\n\n1. **Installation**: Install Kequapp via npm with a simple command:\n   ```\n   npm i kequapp\n   ```\n\n2. **Hello World Example**: Follow our step-by-step [Hello World](/getting-started/hello-world.html) example to see it in action.\n\n3. **Core Concepts**: Learn about the core concepts and API methods that make Kequapp powerful and easy to use in the [Basic Concepts](basic-concepts.md) section.\n\nWe believe Kequapp will provide you with the tools and flexibility you need to build great web applications. Dive into the documentation to explore more about each feature and how to leverage them in your projects.\n\nIf you have any questions, need further assistance, or want to contribute, feel free to reach out to us on our [GitHub page](https://github.com/Kequc/kequapp).\n\nHappy coding!\n"}]},{"title":"Basic Concepts","url":"/docs/basic-concepts.html","sections":[{"title":"createApp()","content":"\nThe `createApp` function is the entry point of your application. It prepares your app to handle incoming requests and serves as the main event handler for Node's `createServer` method.\n\n```javascript\nimport { createApp } from 'kequapp';\n\nconst app = createApp({\n    routes: [\n        {\n            method: 'GET',\n            url: '/',\n            actions: [() => 'Hello world!']\n        }\n    ]\n});\n```\n\n"},{"title":"createBranch()","content":"\nThe `createBranch` function allows you to organize your routes and middleware into logical sections, or branches. Each branch can have its own set of routes, actions, error handlers, and renderers.\n\n```javascript\nimport { createBranch } from 'kequapp';\n\nconst userBranch = createBranch({\n    url: '/users',\n    routes: [\n        {\n            method: 'GET',\n            url: '/',\n            actions: [() => ({ users: [] })]\n        }\n    ]\n});\n```\n\n"},{"title":"createRoute()","content":"\nRoutes define the endpoints of your application. Each route specifies a method (`GET`, `POST`, etc.) and a URL. Routes are the building blocks of your application's API.\n\n```javascript\nimport { createRoute } from 'kequapp';\n\nconst getUserRoute = createRoute({\n    method: 'GET',\n    url: '/users/:id',\n    actions: [({ params }) => ({ userId: params.id })]\n});\n```\n\n"},{"title":"createAction()","content":"\nactions are functions that process requests. They can modify the request and response objects, perform authentication, validation, or any other processing needed. actions are executed in sequence.\n\n```javascript\nimport { createAction } from 'kequapp';\n\nconst jsonHandle = createAction(({ res }) => {\n    res.setHeader('Content-Type', 'application/json');\n});\n```\n\n"},{"title":"createErrorHandler()","content":"\nError handlers are invoked when an action throws an exception. They turn errors into useful information that is sent to the client. You can create custom error handlers to provide better error responses.\n\n```javascript\nimport { createErrorHandler } from 'kequapp';\n\nconst textErrorHandler = createErrorHandler({\n    contentType: 'text/*',\n    action: (ex, { url }) => `${url.pathname} ${ex.statusCode}: ${ex.message}`\n});\n```\n\n"},{"title":"createRenderer()","content":"\nRenderers are responsible for finalizing the response to the client. When an action returns a value, a renderer is invoked to send the response. You can create custom renderers for different content types.\n\n```javascript\nimport { createRenderer } from 'kequapp';\n\nconst htmlRenderer = createRenderer({\n    contentType: 'text/html',\n    action: (payload, { req, res }) => {\n        const html = myMarkupRenderer(payload);\n\n        res.setHeader('Content-Length', Buffer.byteLength(html));\n\n        // finalize response\n        if (req.method === 'HEAD') {\n            res.end();\n        } else {\n            res.end(html);\n        }\n    }\n});\n```\n\nUnderstanding these core concepts will help you build robust and scalable applications with Kequapp. As you explore the documentation, you'll find more details and examples to guide you through each feature.\n\nHappy coding!\n"}]},{"title":"Installation","url":"/getting-started/installation.html","sections":[]},{"title":"Hello World","url":"/getting-started/hello-world.html","sections":[]},{"title":"createApp","url":"/core-api/create-app.html","sections":[{"title":"Example","content":"\n```javascript\nconst app = createApp({\n    routes: [\n        {\n            method: 'GET',\n            url: '/',\n            actions: [() => 'Hello world!']\n        }\n    ]\n});\n```\n"}]},{"title":"createBranch","url":"/core-api/create-branch.html","sections":[{"title":"Example","content":"\n```javascript\ncreateBranch({\n    branches: [\n        {\n            url: '/api/users',\n            actions: [json],\n            routes: [\n                {\n                    method: 'GET',\n                    url: '/',\n                    actions: [() => ({ result: [] })]\n                },\n                {\n                    method: 'GET',\n                    url: '/:id',\n                    actions: [({ params }) => ({ userId: params.id })]\n                }\n            ]\n        }\n    ],\n    routes: [\n        {\n            method: 'GET',\n            url: '/admin/dashboard',\n            actions: [loggedIn, ({ context }) => `Hello admin ${context.auth}`]\n        }\n    ]\n});\n```\n"}]},{"title":"createRoute","url":"/core-api/create-route.html","sections":[{"title":"Example","content":"\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/admin/users',\n    actions: [loggedIn, () => 'User created!']\n});\n```\n\nThis example has two actions. One called `loggedIn()`, then a second that returns a value which is therefore delivered to a renderer.\n"}]},{"title":"createAction","url":"/core-api/create-action.html","sections":[{"title":"Example","content":"\n```javascript\nconst json = createAction(({ res }) => {\n    res.setHeader('Content-Type', 'application/json');\n});\n\nconst loggedIn = createAction(({ req, context }) => {\n    if (req.headers.authorization !== 'mike') {\n        throw Ex.Unauthorized();\n    }\n    context.auth = req.headers.authorization;\n});\n```\n\nIn these examples the `json()` action sets the `'Content-Type'` header to `'application/json'`, and the `loggedIn()` action checks for an `'authorization'` header from the client. actions can be asyncronous and always run in sequence.\n"}]},{"title":"createErrorHandler","url":"/core-api/create-error-handler.html","sections":[{"title":"Example","content":"\n```javascript\ncreateErrorHandler({\n    contentType: 'text/*',\n    action: (ex, { url }) => {\n        return `${url.pathname} ${ex.statusCode}: ${ex.message}`;\n    }\n});\n```\n\nErrors thrown within an error handler or the renderer it invokes will cause a fatal exception and an empty `body` will be delivered to the client.\n"}]},{"title":"createRenderer","url":"/core-api/create-renderer.html","sections":[]},{"title":"Responding to Requests","url":"/advanced-usage/responding-to-requests.html","sections":[]},{"title":"CORS and OPTIONS Requests","url":"/advanced-usage/cors-and-options-requests.html","sections":[]},{"title":"HEAD Requests","url":"/advanced-usage/head-requests.html","sections":[]},{"title":"Ex","url":"/utilities/ex.html","sections":[]},{"title":"staticDirectory","url":"/utilities/static-directory.html","sections":[]},{"title":"sendFile","url":"/utilities/send-file.html","sections":[]},{"title":"inject","url":"/utilities/inject.html","sections":[]},{"title":"Bundle Properties","url":"/additional-information/bundle-properties.html","sections":[{"title":"req","content":"\nNode's [ClientRequest](https://nodejs.org/api/http.html#class-httpclientrequest) object. It is not modified by this framework so we can rely on the official documentation to use it. This represents the client request.\n\n"},{"title":"res","content":"\nNode's [ServerResponse](https://nodejs.org/api/http.html#class-httpserverresponse) object. It is not modified by this framework so we can rely on the official documentation to use it. This represents the server response.\n\n"},{"title":"url","content":"\nIf we need to know more about what the client is looking at in the url bar we can do so here. It is a [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) instance generated from the `req` object.\n\nUseful for examining the query string, for example by digging into [searchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).\n\n```javascript\ncreateRoute({\n    method: 'GET',\n    url: '/hotels',\n    actions: [({ url }) => {\n        const page = url.searchParams.get('page');\n        const categories = url.searchParams.getAll('categories');\n\n        // page ~= '2'\n        // categories ~= ['ac', 'hottub']\n    }]\n});\n```\n\n"},{"title":"methods","content":"\nAn array of methods available in our app at the current url.\n\n"},{"title":"context","content":"\nA place to store variables derived by actions, we might use these variables elsewhere in our code. Changes can be made here whenever we want and it may be populated with anything.\n\nMaybe authentication details, a user object, or any data that's used in other places.\n\n"},{"title":"params","content":"\nWhen defining a route we can specify parameters to extract by prefixing a colon `':'` character in the url. If we specify a route such as `'/users/:userId'` we will have a `params` item called `'userId'`. Use a double asterisk `'/**'` to accept anything for the remainder of the url, we will have a `params` item called `'wild'`.\n\nParam values are always a string.\n\n"},{"title":"cookies","content":"\nIncludes helpers for `get()`, `set()`, and `remove()`. The `set()` method takes an optional third parameter with `expires`, `maxAge`, `domain`, `path`, `secure`, `httpOnly`, `partitioned`, and `sameSite`.\n\n```javascript\ncreateAction(({ cookies }) => {\n    // get a cookie\n    const value: string | undefined = cookies.get('MyCookie');\n    // set a cookie\n    cookies.set('MyCookie', 'NewValue', { maxAge: 10000 });\n    // remove a cookie\n    cookies.remove('MyCookie');\n});\n```\n\n"},{"title":"logger","content":"\nThe logger being used by the application.\n\n"},{"title":"getBody","content":"\nThis method can be used in many ways so the next section will look at it in detail.\n"}]},{"title":"getBody","url":"/additional-information/get-body.html","sections":[{"title":"multipart","content":"\nCauses the method to return both `body` and `files`. If the client didn't send any files, or it wasn't a multipart request the second parameter will be an empty array.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const [body, files] = await getBody({ multipart: true });\n\n        // body ~= {\n        //     name: 'April'\n        // }\n        // files ~= [{\n        //     headers: {\n        //         'content-disposition': 'form-data; name=\"avatar\" filename=\"my-cat.png\"',\n        //         'content-type': 'image/png;'\n        //     },\n        //     contentType: 'image/png',\n        //     name: 'avatar',\n        //     filename: 'my-cat.png',\n        //     data: Buffer <...>\n        // }]\n\n        return \\`User creation \\${body.name}!\\`;\n    }]\n});\n```\n\n"},{"title":"raw","content":"\nCauses the body to be processed as minimally as possible and return a single buffer. This is especially useful when our application expects a content type other than `'application/x-www-form-urlencoded'`, `'application/json'`, or `'multipart/form-data'`.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const data = await getBody({ raw: true });\n\n        // data ~= Buffer <...>\n\n        return 'Image received!';\n    }]\n});\n```\n\nWhen combined with `multipart`, the body is parsed into an array of separate buffers with their respective headers.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const parts = await getBody({ raw: true, multipart: true });\n\n        // parts ~= [{\n        //     headers: {\n        //         'content-disposition': 'form-data; name=\"name\"'\n        //     },\n        //     data: Buffer <...>\n        // }, {\n        //     headers: {\n        //         'content-disposition': 'form-data; name=\"avatar\" filename=\"my-cat.png\"',\n        //         'content-type': 'image/png;'\n        //     },\n        //     data: Buffer <...>\n        // }]\n\n        return \\`User creation \\${parts[0].data.toString()}!\\`;\n    }]\n});\n```\n\n"},{"title":"skipNormalize","content":"\nBy default, the data received is pushed through some body normalization. This is so that the body we receive is in a format we expect and is therefore easier to work with. Normalization is directed by `arrays`, `required`, `numbers`, `booleans`, and `validate`.\n\nDisable body normalization with either `raw` or `skipNormalize`.\n\n"},{"title":"arrays","content":"\nThe provided list of fields are converted into arrays.\n\nFields that are not specified will return only the first value. This is because the framework only knows that a field is an array when it receives more than one value for a given name from the client. It would be inconvenient if parameters are sometimes arrays, and therefore we are explicit.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const body = await getBody({\n            arrays: ['ownedPets']\n        });\n\n        // body ~= {\n        //     ownedPets: ['cat'],\n        //     age: '23',\n        //     name: 'April'\n        // }\n    }]\n});\n```\n\n"},{"title":"required","content":"\nThe provided list of fields are not `null` or `undefined`. It's a quick way to throw a `422 Unprocessable Entity` error. These fields might still be empty, but at least something was sent and we know we can operate on them. When a `required` field is also an `arrays` field the array is sure to have at least one value.\n\n"},{"title":"numbers","content":"\nThe provided list of fields will throw a `422 Unprocessable Entity` error if any value is provided which parses into `NaN`. Otherwise they are converted into numbers.\n\nWhen a `numbers` field is also an `arrays` field the array is all numbers.\n\n"},{"title":"booleans","content":"\nThe provided list of fields are converted into `false` if the value is falsy, `'0'`, or `'false'` (case insensitive), otherwise `true`. When a `booleans` field is also an `arrays` field the array is all booleans. When a `booleans` field is also a `numbers` field the value is first converted to a number and then to a boolean this is not recommended.\n\n"},{"title":"validate","content":"\nAfter normalization, this method further ensures the validity of the data. Returning anything throws a `422 Unprocessable Entity` error.\n\n```javascript\ninterface TBody {\n    ownedPets: string[];\n    age: number;\n    name: string;\n}\n\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const body = await getBody<TBody>({\n            arrays: ['ownedPets'],\n            required: ['age', 'name'],\n            numbers: ['age'],\n            validate (result) {\n                if (result.ownedPets.length > 99) {\n                    return 'Too many pets';\n                }\n                if (result.name.length < 3) {\n                    return 'Name is too short';\n                }\n            }\n        });\n\n        // body ~= {\n        //     ownedPets: ['Maggie', 'Ralph'],\n        //     age: 23,\n        //     name: 'April'\n        // }\n    }]\n});\n```\n\nWe know it is safe to use `result.ownedPets.length` in this example because it is listed as an `arrays` field and therefore certain to be an array. `result.name` is also safe to use because it is listed as a `required` field and therefore certain to exist.\n"}]},{"title":"Logger","url":"/additional-information/logger.html","sections":[]},{"title":"Conclusion","url":"/additional-information/conclusion.html","sections":[]}]
