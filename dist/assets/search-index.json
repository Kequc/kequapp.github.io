[{"title":"Introduction","url":"/","sections":[{"title":"Why Kequapp?","content":"\nKequapp is crafted with simplicity and modularity in mind. Here are some key features that make Kequapp stand out:\n\n- **Modular Framework**: Build your application with a modular structure, making it easy to manage and scale.\n- **CORS Support**: Handle Cross-Origin Resource Sharing effortlessly with built-in support.\n- **Body Parsing**: Comprehensive body parsing capabilities, including support for multipart requests.\n- **Async/Await Everywhere**: Modern asynchronous handling with async/await throughout the framework.\n- **Static File Serving**: Serve static files efficiently and effortlessly.\n- **Unit Testing Tool**: Built-in unit testing tool to ensure your application is robust and reliable.\n- **No Dependencies**: Kequapp has zero dependencies, ensuring a lightweight and fast setup.\n- **Node Features and Functionality**: Exposes and leverages the full power of Node.js.\n\n"},{"title":"Getting Started","content":"\nI want to make your experience with Kequapp as smooth as possible. Hereâ€™s a quick guide to get you started:\n\n1. **Installation**: Install Kequapp via npm with a simple command:\n   ```\n   npm i kequapp\n   ```\n\n2. **Hello World**: Follow the simple [Hello World](/getting-started/hello-world.html) example to see it in action.\n\nI believe Kequapp will provide you with the tools and flexibility you need to build great web applications. Dive into the documentation to explore more about each feature and how to leverage them in your projects.\n\nIf you have any questions, need further assistance, or want to contribute, feel free to reach out on the <a href=\"https://github.com/Kequc/kequapp\" target=\"_blank\">GitHub page</a>.\n"}]},{"title":"Basic Concepts","url":"/docs/basic-concepts.html","sections":[{"title":"Content Type","content":"\nThe `'Content-Type'` header has a huge impact on the way your application responds. Based on this header Kequapp determines which error handler to use, and which renderer to use.\n\nThis structure helps to ensure that the correct `'Content-Type'` is being returned whenever possible. A user expecting to see a `'application/json'` response instead of a `'text/html'` response will probably get one.\n\nBe sure to set your `'Content-Type'` header deliberately and make use of error handlers and renderers that are set up to take advantage of this.\n\n"},{"title":"Branches","content":"\nThe `createApp` function acts as the trunk of the tree where all behaviors derive. It is effectively a branch that stems from `'/'` and is a great place to add functionality that will effect the whole application.\n\nThe app can have branches added using `createBranch` that also resolve to `'/'`, branches are not overridden. In the background all route endpoints are sorted and cataloged upon app startup.\n\nTherefore branching your application with different functionality and same urls is fine.\n\nEven if you have many branches with similar urls containing many routes with different bahavior, Kequapp will sort this out behind the scenes. Duplicate routes however will give you a warning. The final result of your app should contain routes that are unique either by url or method (`GET`, `POST`, etc.) so that there is no conflict.\n\n"},{"title":"Actions","content":"\nThe `createAction` function is simply a wrapper for a function, for cases where you find yourself writing functionality outside the scope of a branch. This is to provide types, but ultimately a function is an action.\n\nActions are littered throughout your application's code base and define the vast majority of your application's behavior. These can be asyncronous and always run in sequence. They are used to check authorization, change response headers, render a response, and more. Most of your code will be wrapped in many different actions.\n\nIt serves to break up your code and make it reusable. Each action comes with many bundle properties that make it easy to manage a web application.\n\n"},{"title":"CORS","content":"\nKequapp is the only JavaScript web framework I am aware of that correctly responds to `OPTIONS` requests. What's more, it still gives you additional control to suit your needs. This is an example of where the structure of this framework shines.\n\nEvery request your application receives knows what matching routes exist at that url. This is what `OPTIONS` responses are supposed to communicate to the client.\n\nIf you need CORS in your application you'll be able to handle those requests as intended.\n\n"},{"title":"Body","content":"\nMany route endpoints do not even care about the body of a request. The `getBody` function is a helper tool that will retrieve that data. It is used inline and awaited in Kequapp, giving you a lot of control over what it is doing.\n\nIf your application makes use of the body of requests in a unique way this framework has you covered. From field validation, processing and formatting incoming data, to allowing you to do it all yourself. Take advantage of the speed gained from not needing to parse the body of a request up front.\n\n"},{"title":"You're all set","content":"\nUnderstanding these core concepts will help you build robust and scalable applications with Kequapp. As you explore the documentation, you'll find more details and examples to guide you through each feature.\n\nThank you for trying your framework I hope it's as enjoyable for you as it is for myself!\n"}]},{"title":"Installation","url":"/getting-started/installation.html","sections":[{"title":"package.json","content":"\n```\n{\n    \"scripts\": {\n        \"start\": \"node ./server.js\"\n    }\n}\n```\n\nIf you like, <a href=\"https://www.npmjs.com/package/nodemon\" target=\"_blank\">nodemon</a> can be used instead to restart the server automatically whenever code changes are made.\n"}]},{"title":"Hello World","url":"/getting-started/hello-world.html","sections":[{"title":"server.js","content":"\n```javascript\nimport { createServer } from 'http';\nimport app from './app';\n\ncreateServer(app).listen(4000, () => {\n    console.log('Server running at http://localhost:4000');\n});\n```\n\n"},{"title":"app.js","content":"\n```javascript\nimport { createApp } from 'kequapp';\n\nexport default createApp({\n    routes: [\n        {\n            method: 'GET',\n            url: '/',\n            actions: [() => 'Hello world!']\n        }\n    ]\n});\n```\n\n"},{"title":"Outcome","content":"\nThis example responds to all `GET` and `HEAD` requests made to `'/'` at the base of your application, otherwise a `404 Not Found` error will be thrown.\n\nKequapp comes with a built-in error handler and some renderers, so for now this is all you need.\n"}]},{"title":"createApp","url":"/core-api/create-app.html","sections":[{"title":"Example","content":"\n```javascript\nconst app = createApp({\n    routes: [\n        {\n            method: 'GET',\n            url: '/',\n            actions: [() => 'Hello world!']\n        }\n    ]\n});\n```\n"}]},{"title":"createBranch","url":"/core-api/create-branch.html","sections":[{"title":"Example","content":"\n```javascript\ncreateBranch({\n    branches: [\n        {\n            url: '/api/users',\n            actions: [setJson],\n            routes: [\n                {\n                    method: 'GET',\n                    url: '/',\n                    actions: [() => ({ result: [] })]\n                },\n                {\n                    method: 'GET',\n                    url: '/:id',\n                    actions: [({ params }) => ({ userId: params.id })]\n                }\n            ]\n        }\n    ],\n    routes: [\n        {\n            method: 'GET',\n            url: '/admin/dashboard',\n            actions: [loggedIn, ({ context }) => `Hello admin ${context.auth}`]\n        }\n    ]\n});\n```\n"}]},{"title":"createRoute","url":"/core-api/create-route.html","sections":[{"title":"Example","content":"\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/admin/users',\n    actions: [loggedIn, () => 'User created!']\n});\n```\n\nThis example has two actions. One called `loggedIn`, then a second that returns a value which is therefore delivered to a renderer.\n"}]},{"title":"createAction","url":"/core-api/create-action.html","sections":[{"title":"Example","content":"\n```javascript\nconst setJson = createAction(({ res }) => {\n    res.setHeader('Content-Type', 'application/json');\n});\n\nconst loggedIn = createAction(({ req, context }) => {\n    if (req.headers.authorization !== 'mike') {\n        throw Ex.Unauthorized();\n    }\n\n    context.auth = req.headers.authorization;\n});\n```\n\nIn these examples the `setJson` action sets the `'Content-Type'` header to `'application/json'`, and the `loggedIn` action checks for an `'authorization'` header.\n"}]},{"title":"createErrorHandler","url":"/core-api/create-error-handler.html","sections":[{"title":"Example","content":"\n```javascript\ncreateErrorHandler({\n    contentType: 'text/*',\n    action: (ex, { url }) => {\n        return `${url.pathname} ${ex.statusCode}: ${ex.message}`;\n    }\n});\n```\n\nErrors thrown within an error handler or the renderer it invokes will cause a fatal exception and an empty `body` will be delivered to the client.\n\nFor a good example of how to write an error handler see this repo's <a href=\"https://github.com/Kequc/kequapp/tree/main/src/built-in\" target=\"_blank\">/src/built-in</a> directory.\n\nKequapp will turn any error into json by default, and return a json formatted response. However this behavior can be overriden by writing your own error handlers that support more specific content types.\n"}]},{"title":"createRenderer","url":"/core-api/create-renderer.html","sections":[]},{"title":"Responding to Requests","url":"/advanced-usage/responding-to-requests.html","sections":[]},{"title":"CORS and OPTIONS Requests","url":"/advanced-usage/cors-and-options-requests.html","sections":[]},{"title":"HEAD Requests","url":"/advanced-usage/head-requests.html","sections":[]},{"title":"Ex","url":"/utilities/ex.html","sections":[]},{"title":"staticDirectory","url":"/utilities/static-directory.html","sections":[]},{"title":"sendFile","url":"/utilities/send-file.html","sections":[]},{"title":"inject","url":"/utilities/inject.html","sections":[]},{"title":"Bundle Properties","url":"/additional-information/bundle-properties.html","sections":[{"title":"req","content":"\nNode's <a href=\"https://nodejs.org/api/http.html#class-httpclientrequest\" target=\"_blank\">ClientRequest</a> object. It is not modified by this framework so we can rely on the official documentation to use it. This represents the client request.\n\n"},{"title":"res","content":"\nNode's <a href=\"https://nodejs.org/api/http.html#class-httpserverresponse\" target=\"_blank\">ServerResponse</a> object. It is not modified by this framework so we can rely on the official documentation to use it. This represents the server response.\n\n"},{"title":"url","content":"\nIf you need to know more about what the client is looking at in the address bar you can do so here. It is a [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) instance generated from the `req` object.\n\nUseful for examining the query string, for example by digging into <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\" target=\"_blank\">searchParams</a>.\n\n```javascript\ncreateRoute({\n    method: 'GET',\n    url: '/hotels',\n    actions: [({ url }) => {\n        const page = url.searchParams.get('page');\n        const categories = url.searchParams.getAll('categories');\n\n        // page ~= '2'\n        // categories ~= ['ac', 'hottub']\n    }]\n});\n```\n\n"},{"title":"methods","content":"\nAn array of methods available in your app at the current url (`GET`, `POST`, `OPTIONS`, etc.).\n\n"},{"title":"context","content":"\nA place to store variables derived by actions, you might use these variables elsewhere in your code. Changes can be made here whenever you want and it may be populated with anything.\n\nMaybe authentication details, a user object, or any data that's useful in other places.\n\n"},{"title":"params","content":"\nWhen defining a route you may specify parameters to extract by prefixing a colon `':'` character in the url. If you specifid a route such as `'/users/:userId'` it will have a `params` item called `'userId'`. Use a double asterisk `'/**'` to accept anything for the remainder of the url, it will have a `params` item called `'wild'`.\n\nParam values are always a string.\n\n"},{"title":"cookies","content":"\nIncludes helpers for `get()`, `set()`, and `remove()`. The `set()` method takes an optional third parameter with `expires`, `maxAge`, `domain`, `path`, `secure`, `httpOnly`, `partitioned`, and `sameSite`.\n\n```javascript\ncreateAction(({ cookies }) => {\n    // get a cookie\n    const value: string | undefined = cookies.get('MyCookie');\n    // set a cookie\n    cookies.set('MyCookie', 'NewValue', { maxAge: 10000 });\n    // remove a cookie\n    cookies.remove('MyCookie');\n});\n```\n\n"},{"title":"logger","content":"\nThe logger being used by the application.\n\n"},{"title":"getBody","content":"\nThis method can be used in many ways so we will look at it in detail the next section.\n"}]},{"title":"getBody","url":"/additional-information/get-body.html","sections":[{"title":"multipart","content":"\nCauses the method to return both `body` and `files`. If the client didn't send any files, or it wasn't a multipart request the second parameter will be an empty array.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const [body, files] = await getBody({ multipart: true });\n\n        // body ~= {\n        //     name: 'April'\n        // }\n        // files ~= [{\n        //     headers: {\n        //         'content-disposition': 'form-data; name=\"avatar\" filename=\"my-cat.png\"',\n        //         'content-type': 'image/png;'\n        //     },\n        //     contentType: 'image/png',\n        //     name: 'avatar',\n        //     filename: 'my-cat.png',\n        //     data: Buffer <...>\n        // }]\n\n        return `User creation ${body.name}!`;\n    }]\n});\n```\n\n"},{"title":"raw","content":"\nCauses the body to be processed as minimally as possible and return a single buffer. This is especially useful when your application expects a content type other than `'application/x-www-form-urlencoded'`, `'application/json'`, or `'multipart/form-data'`.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const data = await getBody({ raw: true });\n\n        // data ~= Buffer <...>\n\n        return 'Image received!';\n    }]\n});\n```\n\nWhen combined with `multipart`, the body is parsed into an array of separate buffers with their respective headers.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const parts = await getBody({ raw: true, multipart: true });\n\n        // parts ~= [{\n        //     headers: {\n        //         'content-disposition': 'form-data; name=\"name\"'\n        //     },\n        //     data: Buffer <...>\n        // }, {\n        //     headers: {\n        //         'content-disposition': 'form-data; name=\"avatar\" filename=\"my-cat.png\"',\n        //         'content-type': 'image/png;'\n        //     },\n        //     data: Buffer <...>\n        // }]\n\n        return `User creation ${parts[0].data.toString()}!`;\n    }]\n});\n```\n\n"},{"title":"skipNormalize","content":"\nBy default, the data received is pushed through some body normalization. This is so that the body you receive is in a format you'd expect and is therefore easier to work with. Normalization is directed by `arrays`, `required`, `numbers`, `booleans`, and `validate`.\n\nDisable body normalization with either `raw` or `skipNormalize`.\n\n"},{"title":"arrays","content":"\nThe provided list of fields are converted into arrays.\n\nFields that are not specified will return only the first value. This is because the framework only knows that a field is an array when it receives more than one value for a given name from the client. It would be inconvenient if parameters are sometimes arrays, and therefore we are explicit.\n\n```javascript\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const body = await getBody({\n            arrays: ['ownedPets']\n        });\n\n        // body ~= {\n        //     ownedPets: ['cat'],\n        //     age: '23',\n        //     name: 'April'\n        // }\n    }]\n});\n```\n\n"},{"title":"required","content":"\nThe provided list of fields are not `null` or `undefined`. It's a quick way to throw a `422 Unprocessable Entity` error. These fields might still be empty, but at least something was sent and you know you can operate on them. When a `required` field is also an `arrays` field the array is sure to have at least one value.\n\n"},{"title":"numbers","content":"\nThe provided list of fields will throw a `422 Unprocessable Entity` error if any value is provided which parses into `NaN`. Otherwise they are converted into numbers.\n\nWhen a `numbers` field is also an `arrays` field the array is all numbers.\n\n"},{"title":"booleans","content":"\nThe provided list of fields are converted into `false` if the value is falsy, `'0'`, or `'false'` (case insensitive), otherwise `true`. When a `booleans` field is also an `arrays` field the array is all booleans. When a `booleans` field is also a `numbers` field the value is first converted to a number and then to a boolean this is not recommended.\n\n"},{"title":"validate","content":"\nAfter normalization, this method further ensures the validity of the data. Returning anything throws a `422 Unprocessable Entity` error.\n\n```javascript\ninterface TBody {\n    ownedPets: string[];\n    age: number;\n    name: string;\n}\n\ncreateRoute({\n    method: 'POST',\n    url: '/users',\n    actions: [async ({ getBody }) => {\n        const body = await getBody<TBody>({\n            arrays: ['ownedPets'],\n            required: ['age', 'name'],\n            numbers: ['age'],\n            validate (result) {\n                if (result.ownedPets.length > 99) {\n                    return 'Too many pets';\n                }\n                if (result.name.length < 3) {\n                    return 'Name is too short';\n                }\n            }\n        });\n\n        // body ~= {\n        //     ownedPets: ['Maggie', 'Ralph'],\n        //     age: 23,\n        //     name: 'April'\n        // }\n    }]\n});\n```\n\nYou know it is safe to use `result.ownedPets.length` in this example because it is listed as an `arrays` field and therefore certain to be an array. `result.name` is also safe to use because it is listed as a `required` field and therefore certain to exist.\n"}]},{"title":"Logger","url":"/additional-information/logger.html","sections":[]},{"title":"Conclusion","url":"/additional-information/conclusion.html","sections":[]}]
